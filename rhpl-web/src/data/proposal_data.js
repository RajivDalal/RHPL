const proposals = [
  {
    "Timestamp": "8-26-2025 11:15:44",
    "Email Address": "PRINCE@IITGOA.AC.IN",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Learning Deterministic One-Counter Automata in Polynomial Time",
    "Name of the presenter": "Prince Mathew",
    "Affiliation": "IIT Goa",
    "Current role/position": "Research Fellow",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Vincent Penelle, University of Bordeaux\nA.V. Sreejith, Indian Institute of Technology Goa",
    "Abstract of your proposal": "We present OL*, a polynomial-time algorithm for active learning of deterministic one-counter automata (DOCA). Unlike previous exponential-time syntactic approaches, OL* is semantic?it learns the language of the target automaton without any knowledge of the DOCA structure. It can also be used to approximate DOCA minimisation, a problem whose exact version is NP-hard even for certain subclasses of DOCA.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Title: Learning Deterministic One-Counter Automata in Polynomial Time\nAuthors: Prince Mathew, Vincent Penelle, A.V. Sreejith\nConference Name: LICS 2025\nURL: https://arxiv.org/abs/2503.04525",
    "Mobile Number": 9447764066,
    "Rank": "A"
  },
  {
    "Timestamp": "9-4-2025 16:19:45",
    "Email Address": "mcsak2346@iacs.res.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Data-Driven Falsification of Cyber-Physical Systems",
    "Name of the presenter": "Atanu Kundu",
    "Affiliation": "Indian Association for the Cultivation of Science",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Rajarshi Ray, Indian Association for the Cultivation of Science\nSauvik Gon, Indian Association for the Cultivation of Science",
    "Abstract of your proposal": "Cyber-Physical Systems (CPS) are abundant in safety-critical domains such as healthcare, avionics, and autonomous vehicles. Formal verification of their operational safety is, therefore, of utmost importance. In this paper, we address the falsification problem, where the focus is on searching for an unsafe execution in the system instead of proving its absence. The contribution of this paper is a framework that (a) connects the falsification of CPS with the falsification of deep neural networks (DNNs) and (b) leverages the inherent interpretability of Decision Trees for faster falsification of CPS. This is achieved by: (1) building a surrogate model of the CPS under test, either as a DNN model or a Decision Tree, (2) application of various DNN falsification tools to falsify CPS, and (3) a novel falsification algorithm guided by the explanations of safety violations of the CPS model extracted from its Decision Tree surrogate. The proposed framework has the potential to exploit a repertoire of adversarial attack algorithms designed to falsify robustness properties of DNNs, as well as state-of-the-art falsification algorithms for DNNs. Although the presented methodology is applicable to systems that can be executed/simulated in general, we demonstrate its effectiveness, particularly in CPS.  We show that our framework implemented as a tool FlexiFal can detect hard-to-find counterexamples in CPS that have linear and non-linear dynamics. Decision tree-guided falsification shows promising results in efficiently finding multiple counterexamples in the ARCH-COMP 2024 falsification benchmarks.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Title: Data-Driven Falsification of Cyber-Physical Systems\nAuthors: Atanu Kundu, Sauvik Gon, and Rajarshi Ray\nJournal: IEEE Transaction on Computer-Aided Design of Integrated Circuits and Systems\nYear: 2025 [Accepted but not yet published]",
    "Mobile Number": 8617035504,
    "Rank": "N"
  },
  {
    "Timestamp": "9-9-2025 12:12:12",
    "Email Address": "cs17m20p100001@iith.ac.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "VEXIR2Vec: An Architecture-Neutral Embedding Framework for Binary Similarity",
    "Name of the presenter": "S. VenkataKeerthy",
    "Affiliation": "IIT Hyderabad",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Soumya Banerjee, IIT Hyderabad\nSayan Dey, IIT Hyderabad\nYashas Andaluri, IIT Hyderabad\nRaghul PS, IIT Hyderabad\nSubrahmanyam Kalyanasundaram, IIT Hyderabad\nFernando Magno Quintao Pereira, UFMG\nRamakrishna Upadrasta, IIT Hyderabad",
    "Abstract of your proposal": "Binary similarity involves determining whether two binary programs exhibit similar functionality with applications in vulnerability detection, malware analysis, and copyright detection. However, variations in compiler settings, target architectures, and deliberate code obfuscations significantly complicate the similarity measurement by effectively altering the syntax, semantics, and structure of the underlying binary. To address these challenges, we propose VexIR2Vec, a robust, architecture-neutral approach based on VEX-IR to solve binary similarity tasks. VexIR2Vec consists of three key components: a peephole extractor, a normalization engine (VexINE), and an embedding model (VexNet). The process to build program embeddings starts with the extraction of sequences of basic blocks, or peepholes, from control-flow graphs via random walks, capturing structural information. These generated peepholes are then normalized using VexINE, which applies compiler-inspired transformations to reduce architectural and compiler-induced variations. Embeddings of peepholes are generated using representation learning techniques, avoiding Out-Of-Vocabulary (OOV) issues. These embeddings are then fine-tuned with VexNet, a feed-forward Siamese network that maps functions into a high dimensional space for diffing and searching tasks in an application-independent manner. \n\nWe evaluate VexIR2Vec against five baselines ? BinDiff, DeepBinDiff, SAFE, BinFinder, and histograms of opcodes ? on a dataset comprising 2.7M functions and 15.5K binaries from \n7 projects compiled across 12 compilers targeting x86 and ARM architectures. The experiments span four adversarial settings ? cross-optimization, cross-compilation, cross-architecture, and obfuscations ? that are typically exploited by malware and vulnerabilities. In diffing experiments, VexIR2Vec outperforms the nearest baseline in these four scenarios by 40%, 18%, 21%, and 60%, respectively. In the searching experiment, VexIR2Vec achieves a mean average precision of 0.76, the nearest baseline, by 46%. Our framework is highly scalable and is built as a lightweight, multi-threaded, parallel library using only open-source tools. VexIR2Vec is about 3.1?3.5x faster than the closest baselines and orders-of-magnitude faster than other tools.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "S. VenkataKeerthy, Soumya Banerjee, Sayan Dey, Yashas Andaluri, Raghul PS, Subrahmanyam Kalyanasundaram, Fernando Magno Quint?o Pereira, and Ramakrishna Upadrasta. 2025. VexIR2Vec: An Architecture-Neutral Embedding Framework for Binary Similarity. ACM Trans. Softw. Eng. Methodol. March 2025. https://doi.org/10.1145/3721481",
    "Mobile Number": "",
    "Rank": "A*"
  },
  {
    "Timestamp": "9-9-2025 17:07:53",
    "Email Address": "sajidsarwar2011@gmail.com",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Exploring Inevitable Waypoints for Unsolvability Explanation in Hybrid Planning Problems",
    "Name of the presenter": "Mir Md Sajid Sarwar",
    "Affiliation": "Indian Association for the Cultivation of Science, Kolkata, India",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Rajarshi Ray, Indian Association for the Cultivation of Science, Kolkata, India",
    "Abstract of your proposal": "Explaining unsolvability of planning problems is of significant research interest in Explainable AI Planning. A number of research efforts on generating explanations of solutions to planning problems have been reported in AI planning literature. However, explaining the unsolvability of planning problems remains a largely open and understudied problem. A widely practiced approach to plan generation and automated problem solving, in general, is to decompose tasks into sub-problems that help progressively converge towards the goal. In this paper, we propose to adopt the same philosophy of sub-problem identification as a mechanism for analyzing and explaining unsolvability of planning problems in hybrid systems. In particular, for a given unsolvable planning problem, we propose to identify common waypoints, which are universal obstacles to plan existence, in other words, they appear on every plan from the source to the planning goal. This work envisions such waypoints as sub-problems of the planning problem and the unreachability of any of these waypoints as an explanation for the unsolvability of the original planning problem. We propose a novel method of waypoint identification by casting the problem as an instance of the longest common subsequence problem, a widely popular problem in computer science, typically considered as an illustrative example for the dynamic programming paradigm. Once the waypoints are identified, we perform symbolic reachability analysis on them to identify the earliest unreachable waypoint and report it as the explanation of unsolvability. We present experimental results on unsolvable planning problems in hybrid domains.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Just Accepted, Transactions on Embedded Computing Systems, 2025",
    "Mobile Number": 9635748978,
    "Rank": "B"
  },
  {
    "Timestamp": "9-12-2025 22:05:07",
    "Email Address": "pankaj.kumar.kalita@ibm.com",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Program Synthesis Meets Visual What-Comes-Next Puzzles",
    "Name of the presenter": "Pankaj Kumar Kalita",
    "Affiliation": "IBM",
    "Current role/position": "Industry researcher/practitioner",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Sumit Lahiri, IIT Kanpur\nAkshay Kumar Chittora, ICICI Bank\nVarun Vankudre, Tessell\nSubhajit Roy, IIT Kanpur",
    "Abstract of your proposal": "What-Comes-Next (WCN) puzzles challenge us to identify the next figure that \"logically follows\" a provided sequence of figures. WCN puzzles are a favorite of interviewers and examiners---there is hardly any aptitude test that misses WCN puzzles. In this work, we propose to automatically synthesize WCN puzzles. The key insight to our methodology is that generation of WCN problems can be posed as a program synthesis problem. We design a small yet expressive language, PuzzlerLang, to capture solutions to WCN puzzles. PuzzlerLang is expressive enough to explain almost all human generated WCN puzzles that we collected, and yet, small enough to allow synthesis in a reasonable time. To ensure that the generated puzzles are appealing to humans, we infer a machine learning model to approximate the appeal factor of given WCN puzzle to humans. We use this model within our puzzle synthesizer as an optimization function to generate highly appealing and correct-by-construction WCN puzzles. We implemented our ideas in a tool, PuzzleGen; we found that PuzzleGen is fast, clocking an average time of about 3.4s per puzzle. Further, statistical tests over the responses from a user-study supported that the PuzzleGen generated puzzles were indistinguishable from puzzles created by humans.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Paper title: Program Synthesis Meets Visual What-Comes-Next Puzzles\nAuthors: Sumit Lahiri, Pankaj Kumar Kalita, Akshay Kumar Chittora, Varun Vankudre, Subhajit Roy\nConference: ASE 2024\nURL: https://dl.acm.org/doi/10.1145/3691620.3695015",
    "Mobile Number": 9101628690,
    "Rank": "A*"
  },
  {
    "Timestamp": "9-15-2025 20:31:20",
    "Email Address": "siddharth.priya@uwaterloo.ca",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Ownership in Low-Level Intermediate Representation",
    "Name of the presenter": "Siddharth Priya",
    "Affiliation": "University of Waterloo",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Arie Gurfinkel, Professor, University of Waterloo",
    "Abstract of your proposal": "High-level languages like Rust show us the power of ownership: it gives both programmers and compilers a clean way to reason about memory safety. However, ownership-based reasoning does not directly help when verifying low-level properties?such as memory safety of the entire Rust program, including unsafe code. At this level (e.g., LLVM IR), pointers are assumed to alias in unrestricted ways, and verification typically requires a heavy address map to represent memory accesses.\n\nIn this talk, I?ll show how we bring ownership into low-level verification. We design ownership semantics for an LLVM-like intermediate representation that let us opportunistically replace some memory operations with fast, ownership-aware reasoning, while still falling back to an address map when needed for unsafe code. We implement this approach in SeaBMC, a bit-precise bounded model checker, and evaluate it on real C programs (augmented with lightweight ownership macros). The result: 1.3??5? speedups in SMT solving, without sacrificing precision.\n\nI?ll highlight the key challenges, walk through our semantic design, and share practical lessons from building and applying this system to mature open-source code.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "@inproceedings{DBLP:conf/fmcad/PriyaG24,\n  author       = {Siddharth Priya and\n                  Arie Gurfinkel},\n  editor       = {Nina Narodytska and\n                  Philipp R{\\\"{u}}mmer},\n  title        = {Ownership in Low-Level Intermediate Representation},\n  booktitle    = {Formal Methods in Computer-Aided Design, {FMCAD} 2024, Prague, Czech\n                  Republic, October 15-18, 2024},\n  pages        = {292--300},\n  publisher    = {{IEEE}},\n  year         = {2024},\n  url          = {https://doi.org/10.34727/2024/isbn.978-3-85448-065-5\\_35},\n  doi          = {10.34727/2024/ISBN.978-3-85448-065-5\\_35},\n  timestamp    = {Mon, 07 Apr 2025 15:29:54 +0200},\n  biburl       = {https://dblp.org/rec/conf/fmcad/PriyaG24.bib},\n  bibsource    = {dblp computer science bibliography, https://dblp.org}\n}",
    "Mobile Number": "",
    "Rank": "B"
  },
  {
    "Timestamp": "9-15-2025 23:28:14",
    "Email Address": "ramneet2001@gmail.com",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "INTERLEAVE: A Faster Symbolic Algorithm for Maximal End Component Decomposition",
    "Name of the presenter": "Ramneet Singh",
    "Affiliation": "Microsoft Research",
    "Current role/position": "Industry researcher/practitioner",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Suguman Bansal, Georgia Institute of Technology",
    "Abstract of your proposal": "The talk presents a novel symbolic algorithm for the Maximal End Component (MEC) decomposition of a Markov Decision Process (MDP). The key idea behind our algorithm INTERLEAVE is to interleave the computation of Strongly Connected Components (SCCs) with eager elimination of redundant state-action pairs, rather than performing these computations sequentially as done by existing state-of-the-art algorithms. Even though our approach has the same complexity as prior works, an empirical evaluation of INTERLEAVE on the standardized Quantitative Verification Benchmark Set demonstrates that it solves 19 more benchmarks (out of 379) than the closest previous algorithm. On the 149 benchmarks that prior approaches can solve, we demonstrate a 3.81x average speedup in runtime.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Title: INTERLEAVE: A Faster Symbolic Algorithm for Maximal End Component Decomposition\nAuthors: Suguman Bansal, Ramneet Singh\nConference: International Conference on Computer Aided Verification (CAV)\nPublication Year: 2025",
    "Mobile Number": 9779192615,
    "Rank": "A*"
  },
  {
    "Timestamp": "9-17-2025 12:55:04",
    "Email Address": "aniket.mishra@iitgn.ac.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Mechanical Specification and Verification for Mitigating Timing-based Side Channel Leaks",
    "Name of the presenter": "Aniket Mishra",
    "Affiliation": "IIT Gandhinagar",
    "Current role/position": "Bachelors student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Abhishek Bichhawat, IIT Gandhinagar",
    "Abstract of your proposal": "In recent times, the mitigation of side channel attacks has become an important concern for security researchers. In this paper, we focus on timing-based side channels introduced through conditional branching on secret information within programs. We introduce a language that allows a programmer to write conditionals branching on secrets within its syntax, but has a semantics that keeps execution time constant with respect to an adversary under an observationally equivalent memory. We differ from other approaches that use program analysis methods, opting instead to modify the operational semantics to enforce the necessary properties. We formalize the semantics for our language with timing leak mitigations in Rocq (previously, Coq) and prove that these semantics satisfy the property of timing-sensitive noninterference. Since our system describes a mitigation approach for timing leaks in a general high-level imperative language, we believe that our semantics can be used as a basis for compiler construction for other high-level imperative languages that seek to be safe from timing side channels.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Fall-through Semantics for Mitigating Timing-based Side Channel Leaks, Aniket Mishra and Abhishek Bichhawat, FSTTCS 2025\n\nDraft: https://drive.google.com/file/d/1gJ6SCEN1Q5jZwGQ6USGSOBZjutkjbbov/view?usp=sharing",
    "Mobile Number": 7980322231,
    "Rank": "N"
  },
  {
    "Timestamp": "9-17-2025 21:34:14",
    "Email Address": "dcsarpi@nus.edu.sg",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Incremental and Unbounded Loop Analysis",
    "Name of the presenter": "Arpita Dutta",
    "Affiliation": "National University of Singapore, Singapore",
    "Current role/position": "Post-Doctoral Fellow",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Joxan Jaffar, National University of Singapore, Singapore",
    "Abstract of your proposal": "We address the problem of proving a loop invariant property within a perpetual loop. We have two goals.  Our first goal is to prove the property holds at over all iterations, ie. to have unbounded verification.  Failing this, our subsequent goal is to determine a loop iteration bound where the property holds, ie. to have the best possible bounded verification. Our framework is set in a harness which is essentially a one loop program whose body comprises a bounded computation, for example, one that does not contain any loops. Our interpreter is based on iterative deepening; it performs bounded reasoning at each iteration, which increases the bound, and has two key features: incrementality, ie. it learns and exploits the result of the previous iteration, and induction, ie. it has a fixpoint-checking mechanism which can detect that the property is invariant throughout all iterations.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Arpita Dutta and Joxan Jaffar. 2025. Incremental and Unbounded Loop Analysis. In Companion Proceedings of the 2025 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity (SPLASH Companion ?25), October 12?18, 2025, Singapore.\n\nhttps://drive.google.com/file/d/1zPVzRoupJmTjShcKsbSmlbEX8htE0mrA/view?usp=sharing",
    "Mobile Number": 8167089559,
    "Rank": "N"
  },
  {
    "Timestamp": "9-17-2025 21:50:53",
    "Email Address": "darshanadask@gmail.com",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "From Theory to Practice: Blackbox Testing in an Industrial Telecom Environment",
    "Name of the presenter": "Darshana Das K",
    "Affiliation": "Government Engineering College Thrissur",
    "Current role/position": "Bachelors student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "",
    "Abstract of your proposal": "Coverage-guided fuzzing has proven highly effective in uncovering software vulnerabilities. However, many industrial systems cannot be instrumented or inspected due to security, legal, or operational constraints. In such settings, blackbox test generation remains the only viable testing strategy.\nThis paper presents a case study in collaboration with our industrial partner where we were tasked with testing the protocol-handling subsystem of a virtualized packet processing engine without access to the source code or internal documentation. To overcome this constraint, we applied blackbox grammar inference techniques to reverse-engineer the input protocol accepted by the system, achieving an F1 score of 0.94 for the inferred protocol grammar. Our blackbox test campaign resulted in 33.6% code coverage, judged as as measured by our industrial partner after the test campaign concluded.\nWe discuss our testing methodology and the practical challenges encountered. This case study highlights current limitations of automatic testing frameworks when deployed in blackbox industrial environments, and offers actionable insights for improving their effectiveness in such settings.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "From Theory to Practice?Blackbox Testing in an Industrial Telecom Environment\nAuthors: Darshana Das K, Krishnahari P, Libna Kuriakose T, Parvathy C M, Ezudheen P, Abraham Jacob, Rahul Gopinath\nVenue: The 36th IEEE International Symposium on Software Reliability Engineering (ISSRE)\nYear- 2025",
    "Mobile Number": 7902384000,
    "Rank": "A"
  },
  {
    "Timestamp": "9-18-2025 10:01:49",
    "Email Address": "lipsy@ksu.edu",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Safety Verification of Anytime Perception based Cyber-Physical Systems",
    "Name of the presenter": "Lipsy Gupta",
    "Affiliation": "Kansas State University",
    "Current role/position": "Research Assistant Professor",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Pavithra Prabhakar, Kansas State University",
    "Abstract of your proposal": "AI-based components are increasingly integrated into autonomous and cyber-physical systems (CPS) by replacing traditional modules such as control, perception, and decision-making. These integrations have led to significant advancements in safety-critical domains, including aerospace, automotive, and robotics. The paradigm of anytime perception has been recently introduced to offer flexibility in latency and accuracy, unlike traditional sensors that return outputs with fixed performance. This adaptability enables autonomous systems to perform more complex tasks while ensuring efficient use of computational resources, but it also introduces new safety challenges, as variations in sensing performance can lead to mission-critical failures. To address these challenges, formal verification is emerging as a powerful framework for providing guarantees on the correctness and safety of such systems.\n\nIn this talk, we focus on the safety verification of anytime perception-based CPS, wherein we model the anytime sensor in the closed loop. We provide an efficient algorithm for reachable set computation of a closed-loop system with an anytime sensor and a neural network controller using the star set data structure and designing new algorithms for some star set operations. We discuss some experimental results that highlight the scalability of the approach and its effectiveness with diverse dynamics, controllers, and sensing configurations.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "1.   L. Gupta and P. Prabhakar. Star-Set Based Efficient Reachable Set Computation of Anytime Sensing-Based Neural Network-Controlled Dynamical Systems. International Conference on Embedded Software (EMSOFT), 2025. (Journal version published in ACM Transactions on Embedded Computing Systems)\n\n\n2. L. Gupta, J. C. Choton, and P. Prabhakar. Safety verification of closed-loop control system with anytime perception. International Conference on Robotics and Automation (ICRA), 2024.",
    "Mobile Number": "+1 5735299859",
    "Rank": "A*"
  },
  {
    "Timestamp": "9-18-2025 11:29:03",
    "Email Address": "tgourav@cse.iitk.ac.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Verification of Open Programs via LLM-Mined Behavioral Idioms",
    "Name of the presenter": "Gourav Takhar",
    "Affiliation": "IIT Kanpur",
    "Current role/position": "Post-Doctoral Fellow",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Baldip Bijlani, IIT Kanpur\nPrantik Chatterjee, Mathworks\nAkash Lal, MSR India\nSubhajit Roy, IIT Kanpur",
    "Abstract of your proposal": "An open program is one for which the complete source code is not available, which is a reality for real-world program verification. Software verification tools tend to assume the worst about any unconstrained behavior, and this can yield an enormous number of spurious warnings for open programs. For any serious verification effort, the engineer must invest time up-front in building a suitable model (or mock) of any missing code, which is time-consuming and error-prone. Inaccuracies in the mocks can lead to incorrect verification results.\n\nIn this paper, we demonstrate a technique that is capable of distinguishing between false positives and actual bugs from potential memory-safety violations in an open program with high accuracy. Central to the technique is the ability of making angelic assumptions about missing code. To accomplish this, we first mine a set of idiomatic patterns in buffer-manipulating programs using a large language model (LLM). This is complemented by a formal synthesis strategy that performs property-directed reasoning to select, adapt and instantiate these idiomatic patterns into angelic assumptions on the target program. Overall, our system, Seeker, guarantees that a program is deemed correct only if it can be verified under a well-defined set of \"trusted'' idiomatic patterns. In our experiments over a set of benchmarks curated from popular open-source software, our tool Seeker is able to identify 79% of the false positives with zero false negatives.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "The paper has been accepted in OOPSLA, but it has not been published yet.\nhttps://2025.splashcon.org/details/OOPSLA/107/Memory-Safety-Verification-of-Open-Programs-With-Angelic-Assumptions\n\nReference:\n\nGourav Takhar, Baldip Bijlani, Prantik Chatterjee, Akash Lal, and Subhajit Roy. 2025. Memory-Safety Verification of Open Programs with Angelic Assumptions. Proc. ACM Program. Lang. 9, OOPSLA2, Article 312(October 2025), 29 pages. https://doi.org/10.1145/3763090",
    "Mobile Number": 9928097844,
    "Rank": "A"
  },
  {
    "Timestamp": "9-18-2025 14:00:35",
    "Email Address": "anand.yeolekar@tcs.com",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Repairing Control Safety Violations by Patching the Real-time OS Scheduler",
    "Name of the presenter": "Anand Yeolekar",
    "Affiliation": "TCS Research",
    "Current role/position": "Industry researcher/practitioner",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Supratik Chakraborty (IIT Bombay) \nR Venkatesh (TCS Research) \nSamarjit Chakraborty (UNC Chapel Hill)",
    "Abstract of your proposal": "Cyber-physical systems are typically implemented in software as a set of real-time control tasks. Timing uncertainty at the low-level scheduling layer can lead to deadline misses of control tasks, that affects control performance and may violate safety properties associated with the high-level control applications. We present a technique to detect and repair control safety violations by synthesizing a scheduler patch ? a pre-computed list of jobs to be not\nscheduled at runtime ? that eliminates these violations without the need of modifications at the control or task layer. The technique utilizes a guess?check?repair loop on top of an exact SMT encoding of control and scheduling behaviours, enabling efficient packing of multiple control applications on the execution platform while guaranteeing control safety.\n\nThe talk will cover SMT modeling of control applications, real-time tasks, and low-level timing uncertainties. Based  on exact modeling of the CPS layers, we present a way to repair the guessed scheduler patch, by refining the initial abstraction with constraints derived from counterexamples, that help distinguish critical task instances from the non-critical ones.  \n\nIf time permits, we will present (published) work on repairing task specifications by automatically tuning selected task parameters like offset and period. These works broadly come under the field of Timing Debugging.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Repairing Control Safety Violations via Scheduler Patch Synthesis\nAuthors as above\nPublished at ICCPS-2025, part of CPS-IoT Week\nhttps://dl.acm.org/doi/abs/10.1145/3716550.3722035",
    "Mobile Number": "",
    "Rank": "N"
  },
  {
    "Timestamp": "9-18-2025 14:53:54",
    "Email Address": "shashikantshvet@gmail.com",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "On The Dolev-Yao Model of Symmetric Cascade Protocol",
    "Name of the presenter": "Dr Varsha Jarali/ Dr Shashi Kant Pandey",
    "Affiliation": "Society For Electronic Transections and Security Chennai",
    "Current role/position": "Industry researcher/practitioner",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "",
    "Abstract of your proposal": "Security protocols enable authentication, key distribution, and secure information exchange, making them essential for network security, yet flaws in their design can lead to attacks. To prevent this, formal verification methods are vital for analyzing protocol correctness. The Dolev?Yao (DY) model introduced formalization for name-stamp and cascade protocols, where users apply public-key operations on messages. Brook and Otto later distinguished between symmetric and non-symmetric cascade protocols, noting that all DY cases were symmetric and that attacker choices were not fully addressed. They highlighted the incomplete characterization of an attacker?s power as an open problem. In this work, we extend the DY model by systematically analyzing all remaining symmetric two-party cascade protocol cases, aiming to provide a more complete foundation for building formal verification tools.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "The draft of the work is available at the flowing link: https://drive.google.com/file/d/1jc0zfMY-o1tqdxqWVXYt7cyHlJgk0ZvH/view?usp=sharing",
    "Mobile Number": 8826185268,
    "Rank": "U"
  },
  {
    "Timestamp": "9-18-2025 14:56:42",
    "Email Address": "santonus@goa.bits-pilani.ac.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "LLM-Assisted Formal Verification Framework for Process Control Software Evolution",
    "Name of the presenter": "Santonu Sarkar",
    "Affiliation": "BITS Goa",
    "Current role/position": "Faculty",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Soumyadip Banerjee, ACM Member",
    "Abstract of your proposal": "This proposal  presents a hybrid approach that combines the adaptability of Large Language Models (LLMs) with the rigor of formal verification for automated software upgrades for Sequential Function Chart (SFC) code. Our framework LLMA combines an LLM component to generate an upgraded version of an existing SFC code, while maintaining strict formal verification to ensure correctness during the upgrade process. Our framework includes: (1) an integrated approach combining formal verification with LLM-guided upgrades; (2) counterexample-driven prompt refinement for learning from verification failures; and (3) automated repair functions that rectify behavioral divergences identified during verification. Evaluations on industrial benchmarks reveal our approach achieves high success rates while substantially reducing manual effort compared to conventional methods",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Formal verification part has been accepted at ATVA 2025",
    "Mobile Number": 8900270263,
    "Rank": "B"
  },
  {
    "Timestamp": "9-18-2025 15:08:36",
    "Email Address": "nobuko.yoshida@cs.ox.ac.uk",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Specification-guided Programming for Asynchronous Message-Passing Optimisation",
    "Name of the presenter": "Nobuko Yoshida",
    "Affiliation": "University of Oxford",
    "Current role/position": "Faculty",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Martin Vassor (Mines Nancy, FRANCE)",
    "Abstract of your proposal": "Rust is a modern systems language focused on performance and reliability. Complementing Rust's promise to provide \"fearless concurrency\", developers frequently exploit asynchronous message passing. Unfortunately, sending and receiving messages in an arbitrary order to maximise computation-communication overlap (a popular optimisation in message-passing applications) opens up a Pandora's box of subtle concurrency bugs.\n \n\nTo guarantee deadlock-freedom by construction, we present Rumpsteak: a new Rust framework based on multiparty session types. Previous session type implementations in Rust are either built upon synchronous and blocking communication and/or are limited to two-party interactions. Crucially, none support the arbitrary ordering of messages for efficiency.\n \n\nRumpsteak instead targets asynchronous async/await code. Its unique ability is allowing developers to arbitrarily order send/receive messages while preserving deadlock-freedom. For this, Rumpsteak incorporates two recent advanced session type theories: (1) k-multiparty compatibility (k-MC), which globally verifies the safety of a set of participants, and (2) asynchronous multiparty session subtyping, which locally verifies optimisations in the context of a single participant. \n\nWe then talk recent work on Rust with multiparty session refinement types.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2024.41",
    "Mobile Number": "+447519259087",
    "Rank": "A"
  },
  {
    "Timestamp": "9-18-2025 17:25:32",
    "Email Address": "alvingeorge@iisc.ac.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "CEGAR for Temporal Properties based on Recurrent Sets",
    "Name of the presenter": "Alvin A. George",
    "Affiliation": "Indian Institute of Science, Bangalore",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Deepak D'Souza, IISc\nPavithra Prabhakar, Kansas State University",
    "Abstract of your proposal": "We consider the problem of verifying linear-time temporal properties, specifically, liveness properties, of discrete-time systems with (uncountable) infinite states   often arising in robotic applications, And present a counter-example guided abstraction refinement (CEGAR) based technique tailored to this setting.\nWe provide novel validation and refinement algorithms to handle the lasso shaped abstract counterexamples that witness the violation of the liveness properties and give a characterization of a feasible lasso-shaped abstract counter-examples based on the notion of recurrent sets.\nUsing this, we propose an algorithm for validating counter-examples by iteratively computing pre-sets around the loop, and use these computed pre-sets to refine the   abstraction to eliminate spurious counter-examples.\nPreliminary results show the technique to be effective in terms of both proving that the system satisfies the given property, as well as in finding valid counter-     examples (falsification).",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "https://alvg.github.io/drafts/cegar-2025.pdf.  If it asks for a password, use password: 2025rhpl",
    "Mobile Number": 8904893696,
    "Rank": "U"
  },
  {
    "Timestamp": "9-20-2025 11:26:59",
    "Email Address": "omkarvt@gmail.com",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "GPUMC: A Stateless Model Checker for GPU Weak Memory Concurrency",
    "Name of the presenter": "Omkar Tuppe",
    "Affiliation": "IIT Bombay",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Soham Chakraborty , TU Delft, Netherlands, IIT Bombay, India\nAndreas Pavlogiannis, Aarhus University, Denmark\nS. Krishna, IIT Bombay, India",
    "Abstract of your proposal": "Modern GPUs adopt weak memory concurrency for performance, but their added complexity, including memory orders, memory scopes, and divergence, makes writing correct concurrent code significantly more complicated than on CPUs.\nTo address this, we developed GPUMC, a stateless model checker for verifying GPU programs under the scoped-RC11 memory model. GPUMC systematically explores all possible executions to detect data races, heterogeneous races, barrier divergence, and assertion violations.\nWe evaluated GPUMC on both micro-benchmarks and GPU kernels. It is efficient in time and memory, verifying large programs where existing tools fail or time out.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Chakraborty, S., Krishna, S., Pavlogiannis, A., Tuppe, O. (2025). \nGPUMC: A Stateless Model Checker for GPU Weak Memory Concurrency. \nIn: Piskac, R., Rakamari?, Z. (eds) Computer Aided Verification. CAV 2025. \nLecture Notes in Computer Science, vol 15933. \nSpringer, Cham. \nhttps://doi.org/10.1007/978-3-031-98682-6_17",
    "Mobile Number": 9665836934,
    "Rank": "A*"
  },
  {
    "Timestamp": "9-20-2025 13:16:40",
    "Email Address": "adityaanand@cse.iitb.ac.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "CoSSJIT: Combining Static Analysis and Speculation in JIT Compilers",
    "Name of the presenter": "Aditya Anand",
    "Affiliation": "Indian Institute of Technology Bombay",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Vijay Sundaresan (IBM Canada)\nDaryl Maier (IBM Canada)\nManas Thakur (Guide) (IIT Bombay)",
    "Abstract of your proposal": "Just-in-time (JIT) compilers typically sacrifice the precision of program analysis for efficiency, but are capable of performing sophisticated speculative optimizations based on run-time profiles to generate code that is specialized to a given execution. On the contrary, ahead-of-time static compilers can often afford precise flow-sensitive interprocedural analysis, but produce conservative results in scenarios where higher precision could be derived from run-time specialization. In this paper, we propose the first-of-its-kind approach to enrich static analysis with the possibility of speculative optimization during JIT compilation, as well as its usage to perform aggressive stack allocation on a production Java Virtual Machine (JVM).\n\n Our approach of combining static analysis with JIT speculation -- named CoSSJIT -- involves three key contributions. First, we identify the scenarios where a static analysis would make conservative assumptions but a JIT could deliver precision based on run-time speculation. Second, we present the notion of \"speculative conditions\" and plug them into a static interprocedural dataflow analyzer (whose aim is to identify heap objects that can be allocated on stack), to generate partial results that can be specialized at run-time. Finally, we extend a production JIT compiler to read and enrich static-analysis results with the resolved values of speculative conditions, leading to a practical approach that efficiently combines the best of both worlds. Cherries on the cake: Using CoSSJIT, we obtain 5.7x improvement in stack allocation (translating to performance), while building on a system that ensures functional correctness during JIT compilation.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Published:\nTitle: \"CoSSJIT: Combining Static Analysis and Speculation in JIT\nCompilers\"\nAuthors: Aditya Anand, Vijay Sundaresan, Daryl Maier, Manas Thakur\nConference: OOPSLA co-located with SPLASH 2025\nYear: 2025",
    "Mobile Number": 8553052758,
    "Rank": "A"
  },
  {
    "Timestamp": "9-27-2025 8:57:42",
    "Email Address": "cs21resch11004@iith.ac.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "GSOHC: Global Synchronization Optimization in Heterogeneous Computing",
    "Name of the presenter": "Soumik Kumar Basu",
    "Affiliation": "IIT Hyderabad",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Jyothi Vedurada, IIT HYDERABAD",
    "Abstract of your proposal": "The use of heterogeneous systems has become widespread and popular in the past decade with more than one type of processor, such as CPUs, GPUs (Graphics Processing Units), and FPGAs (Field Programmable Gate Arrays) etc. A wide range of applications use both CPU and GPU to leverage the benefits of their unique features and strengths. Therefore, collaborative computation between CPU and GPU is essential to achieve high program performance. However, poorly placed global synchronization barriers and synchronous memory transfers are the main bottlenecks to enhanced program performance, preventing CPU and GPU computations from overlapping. \nBased on this observation, we propose a new optimization technique called hetero-sync motion that can relocate such barrier instructions to new locations, resulting in improved performance in CPU-GPU heterogeneous programs. Further, we propose GSOHC, a compiler analysis and optimization framework that automatically finds opportunities for hetero-sync motion in the input program and then performs code transformation to apply the optimization. Our static analysis is a context-sensitive, flow-sensitive inter-procedural data-flow analysis with three phases to identify the optimization opportunities precisely. We have implemented GSOHC using LLVM/Clang infrastructure. On A4000, P100 and A100 GPUs, our optimization achieves speedups of up to 1.8x, 1.9x and 1.9x over the baseline, respectively.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Publication title: GSOHC Global Synchronisation optimization for Heterogeneous Computing \nAuthors: Soumik Kumar Basu and Jyothi Vedurada \nVenue: ECOOP 2025",
    "Mobile Number": "09163784761",
    "Rank": "A"
  },
  {
    "Timestamp": "9-27-2025 17:15:44",
    "Email Address": "sumitl@cse.iitk.ac.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Almost correct invariants: synthesizing inductive invariants by fuzzing proofs",
    "Name of the presenter": "Sumit Lahiri",
    "Affiliation": "Indian Institute Of Technology Kanpur",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Dr. Subhajit Roy, Indian Institute Of Technology Kanpur",
    "Abstract of your proposal": "Real-life programs contain multiple operations whose semantics are unavailable to verification engines, like third-party library calls, inline assembly and SIMD instructions, special compiler-provided primitives, and queries to uninterpretable machine learning models. Even with the exceptional success story of program verification, synthesis of inductive invariants for such \"open\" programs has remained a challenge. Currently, this problem is handled by manually \"closing\" the program---by providing hand-written stubs that attempt to capture the behavior of the unmodelled operations; writing stubs is not only difficult and tedious, but the stubs are also often incorrect---raising serious questions on the whole endeavor. In this work, we propose Almost Correct Invariants as an automated strategy for synthesizing inductive invariants for such \"open\" programs. We adopt an active learning strategy where a data-driven learner proposes candidate invariants. In deviation from prior work that attempt to verify invariants, we attempt to falsify the invariants: we reduce the falsification problem to a set of reachability checks on non-deterministic programs; we ride on the success of modern fuzzers to answer these reachability queries. Our tool, Achar, automatically synthesizes inductive invariants that are sufficient to prove the correctness of the target programs. We compare Achar with a state-of-the-art invariant synthesis tool that employs theorem proving on formulae built over the program source. Though Achar is without strong soundness guarantees, our experiments show that even when we provide almost no access to the program source, Achar outperforms the state-of-the-art invariant generator that has complete access to the source. We also evaluate Achar on programs that current invariant synthesis engines cannot handle---programs that invoke external library calls, inline assembly, and queries to convolution neural networks; Achar successfully infers the necessary inductive invariants within a reasonable time.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Almost correct invariants: synthesizing inductive invariants by fuzzing proofs\nSumit Lahiri, Subhajit Roy\nhttps://dl.acm.org/doi/10.1145/3533767.3534381",
    "Mobile Number": 9007342270,
    "Rank": "A"
  },
  {
    "Timestamp": "9-29-2025 15:03:44",
    "Email Address": "shibashis@tifr.res.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Continuous Time Reward Machines",
    "Name of the presenter": "Shibashis Guha",
    "Affiliation": "Tata Institute of Fundamental Research Mumbai",
    "Current role/position": "Faculty",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Amin Falah, University of Colorado Boulder\nAshutosh Trivedi, University of Colorado Boulder",
    "Abstract of your proposal": "Reinforcement Learning (RL) is a sampling-based method for sequential decision-making, in which a learning agent iteratively converges toward an optimal policy by leveraging feedback from the environment in the form of scalar reward signals. While timing information is often abstracted in discrete-time domains, time-critical learning applications?such as queuing systems, population processes, and manufacturing systems?are naturally modeled as Continuous-Time Markov Decision Processes (CTMDPs). Since the seminal work of Bradtke and Duff, model-free RL for CTMDPs has become well-understood. However, in many practical applications, practitioners possess high-quality information about system rates derived from traditional queuing theory, which learning agents could potentially exploit to accelerate convergence. Despite this, classical RL algorithms for CTMDPs typically re-learn these parameters through sampling. In this work, we propose continuous-time reward machines (CTRMs), a novel framework that embeds reward functions and real-time state-action dynamics into a unified structure. CTRMs enable RL agents to effectively navigate dense-time environments while leveraging reward shaping and counterfactual experiences for accelerated learning. Our empirical results demonstrate CTRMs' ability to improve learning efficiency in time-critical environments.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Title: Continuous-Time Reward Machines\nAuthors: Amin Falah. Shibashis Guha, Ashutosh Trivedi\nConference: International Joint Conference on Artificial Intelligence, {IJCAI}\nYear: 2025",
    "Mobile Number": "",
    "Rank": "A*"
  },
  {
    "Timestamp": "10-2-2025 19:28:05",
    "Email Address": "official.abhishek.de@gmail.com",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "A proofs vs programs correspondence for the epsilon calculus",
    "Name of the presenter": "Abhishek De",
    "Affiliation": "Krea University",
    "Current role/position": "Faculty",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Bruno da Rocha Paiva, University of Birmingham",
    "Abstract of your proposal": "The proofs vs programs (aka the Curry-Howard correspondence) correspondence is a deep connection between logic and programming languages where formulas correspond to types, proofs to programs, and normalisation to evaluation. \n\nIn the early 20th century in order to solve the foundational crisis, Hilbert and Bernays invented the \"epsilon-calculus\", a logic obtained by adding a choice operator to predicate logic. Epsilon-calculus was largely forgotten in lieu of first order logic, however, there has been some renewed interest in its proof theory in the last few decades.\n\nIn this talk, we explore the proofs vs programs correspondence for the epsilon calculus. It turns out that epsilon calculus has some mild classical features which gives us some computational effects at the level of programs.\n\nThis is a work in progress with Bruno da Rocha Paiva.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Not available. Work in preliminary stage.",
    "Mobile Number": 9831152837,
    "Rank": "U"
  },
  {
    "Timestamp": "10-2-2025 22:31:27",
    "Email Address": "tephilla.prince.18@iitdh.ac.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Bridging Nets-within-Nets and Data Nets",
    "Name of the presenter": "Tephilla Prince",
    "Affiliation": "Indian Institute of Technology Dharwad, India",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Francesco Di Cosmo, Free University of Bozen-Bolzano, Italy\nSoumodev Mal, Chennai Mathematical Institute, India",
    "Abstract of your proposal": "Elementary Object Systems (EOSs) are a model in the nets-within-nets (NWNs) paradigm, where tokens in turn can host standard Petri nets. We study the complexity of the reachability problem of EOSs when subjected to non-deterministic token losses. \nIt is known that this problem is equivalent to the coverability problem with no lossiness of conservative EOSs (cEOSs).\nWe precisely characterize cEOS coverability into the framework of data nets, whose tokens carry data from an infinite domain. Specifically, we show that cEOS coverability is equivalent to the coverability of an interesting fragment of data nets that extends beyond nu-PN (featuring globally fresh name creation), yet remains less expressive than Unordered Data Nets (featuring lossy name creation as well as powerful forms of whole-place operations and broadcasts). \nThis insight bridges two apparently orthogonal approaches to PN extensions, namely data nets and NWNs. At the same time, it enables us to analyze cEOS coverability taking advantage of known results on data nets.\nAs a byproduct, we immediately get that the complexity of cEOS coverability lies between F_\\omega 2 and F_\\omega^\\omega,  two classes beyond Primitive Recursive",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "This work is published under the title ?Nets-within-nets through the Lens of Data Nets? at the 19th International Conference on Reachability Problems, October, 2025.",
    "Mobile Number": 8056702114,
    "Rank": "N"
  },
  {
    "Timestamp": "10-3-2025 20:03:33",
    "Email Address": "supriyabhide@cse.iitb.ac.in",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "CoS-SSA: Context-Sensitive SSA for Interprocedural Program Analyses and Optimisations",
    "Name of the presenter": "Supriya Bhide",
    "Affiliation": "Indian Institute of Technology Bombay",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Uday Khedker, Indian Institute of Technology Bombay\nPritam Gharat, Microsoft Research India",
    "Abstract of your proposal": "Static Single Assignment (SSA) is the most commonly used intermediate representation by all modern compilers. The advent of SSA in the late 80? s brought about a major change in how programs were represented, analyzed, and optimized by compilers. Since then, SSA has seen many advances and has become the de facto intermediate representation used by modern compilers such as GCC and LLVM. The main advantage of SSA is that it enables referential transparency for variables by ensuring that there is a single definition of any variable and this definition is connected to its uses through def-use edges. This provides flow-sensitivity for free thereby enabling sparse analyses.\n\nCurrent SSA (aka classical SSA) works only at the intraprocedural level and is restricted to non-address-taken variables. Address-taken variables and global variables are handled soundly but very imprecisely using memory-SSA [6, 14]. However, no def-use edges can be formed when the definitions and their uses are in different procedures. This restricts the scope of SSA-based analysis and optimisations to individual procedures. To overcome these limitations, we propose a precise interprocedural SSA form called CoS-SSA (Context-Sensitive SSA) that generalises the classical SSA to support def-use edges between global variables across procedures even in the presence of pointers and recursion. CoS-SSA provides context-sensivity for free, apart from flow-sensitivity?a client analysis that uses CoS-SSA does not require to maintain context sensitivity or flow sensitivity. This enables efficient sparse analyses at the interprocedural level. We also describe an algorithm for constructing CoS-SSA efficiently. \n\nSince this is an unpublished work, the document whose link has been given below, provides a high-level description omitting the formalism. We will provide detailed mathematical formalism if required.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "https://drive.google.com/drive/folders/1fjlBAQJw8ryI8SuP_Q6JEi_HZ-RCC322?usp=sharing",
    "Mobile Number": 9082600648,
    "Rank": "U"
  },
  {
    "Timestamp": "10-4-2025 2:34:21",
    "Email Address": "admin@anthroplogic.onmicrosoft.com",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Emdash ? A Dependently Typed Logical Framework for Computational Synthetic ?-Category Theory and Functorial Elaboration",
    "Name of the presenter": "Cristopher Mary Kouam",
    "Affiliation": "BITS Pilani",
    "Current role/position": "Faculty",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "",
    "Abstract of your proposal": "**Abstract.** We present Emdash, a novel dependently typed logical framework designed to support computational synthetic category theory, drawing inspiration from Kosta Dosen's functorial programming paradigm. Emdash integrates categorical primitives?such as categories, objects, morphisms, and functors?directly into its ??-calculus core, facilitating reasoning and computation in a style closer to mathematical practice. The path towards ?-categories is paved by internalizing the (dependent) comma category construction of a (dependent) category, similarly as for the \"bridge type\" construction in the technique of logical relations/parametricity. The system features a bidirectional type checker with unification-based hole solving for interactive proof, definitional equality via ??-reduction (including user-supplied rewrite rules and unfolding of injective constants), and Higher-Order Abstract Syntax (HOAS) for binders. A key contribution of Emdash is the concept of *functorial elaboration*, where kernel-level constructors for structures like functors not only receive their components (e.g., object and arrow mappings) but also definitionally verify their coherence laws (e.g., functoriality) during the elaboration process itself, throwing a `CoherenceError` upon failure. Implemented in TypeScript and formally specified in a Lambdapi dialect, Emdash demonstrates a practical pathway from specification to a working kernel. This paper details the Emdash framework, its core algorithms, its interactive proof mode, its alignment with its formal specification, and its role as the formal engine for hotdocX, a web-based platform for AI-assisted formalization of mathematical documents. We report on the successful implementation and validation of the system's core features through a comprehensive test suite. Source: https://github.com/hotdocx/emdash/blob/main/docs/emdash.pdf\n\n**Keywords:** Dependent Type Theory, Logical Frameworks, Category Theory, Functorial Programming, Synthetic Mathematics, Interactive Theorem Proving, AI-Assisted Formalization, Lambdapi, TypeScript.\n\n## References\n\n[1] Dosen, K., & Petri?, Z. (1999). *Cut-Elimination in Categories*.  \n\n[2] Dosen, K., & Petri?, Z. (2004). *Proof-Theoretical Coherence*. KCL Publications.  \n\n[3] Blanqui, F. (Ongoing). *Lambdapi Logical Framework*. Deducteam. https://github.com/Deducteam/lambdapi\n\n[4] The Univalent Foundations Program. (2013). *Homotopy Type Theory: Univalent Foundations of Mathematics*. Institute for Advanced Study.  \n\n[5] Polu, S., et al. (2022). *Formal Mathematics Statement Curriculum Learning*. arXiv:2202.01344.  \n\n[6] OpenAI et al. (Various). Research on models like GPT-f for formal mathematics.  \n\n[7] hotdocX Project. https://hotdocx.github.io  \n\n[8] emdash Project. https://github.com/hotdocx/emdash\n\n[9] 1337777. (2024). *Cartier Solution 16 (Schemes)*. https://github.com/1337777/cartier/blob/master/cartierSolution16.lp\n\n[10] 1337777. (2024). *Cartier Solution 18 (Emdash Spec)*. https://github.com/1337777/cartier/blob/master/cartierSolution18.lp\n\n[11] hotdocX. (2024). *jsCoq Template Example*. https://hotdocx.github.io/#/hdx/25191CHRI43000\n\n[12] hotdocX. (2024). *Arrowgram AI Template Example*. https://hotdocx.github.io/#/hdx/25188CHRI26000\n\n[13] hotdocX. (2024). *Emdash Re-formattable Example*. https://hotdocx.github.io/#/hdx/25188CHRI25004\n\n[14] hotdocX. (2024). *Emdash Experiment-able Example*. https://hotdocx.github.io/#/hdx/25188CHRI27000\n\n[15] Arrowgram Project. https://github.com/hotdocx/arrowgram\n\n[16] hotdocX Sponsorship. https://github.com/sponsors/hotdocx",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "https://github.com/hotdocx/emdash/blob/main/docs/emdash.pdf",
    "Mobile Number": "+1 6469613489",
    "Rank": "U"
  },
  {
    "Timestamp": "10-21-2025 11:40:51",
    "Email Address": "umathur@nus.edu.sg",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Equivalences for Causal Concurrency",
    "Name of the presenter": "Umang Mathur",
    "Affiliation": "National University of Singapore",
    "Current role/position": "Faculty",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Azadeh Farzan (University of Toronto)\nZhendong Ang (National University of Singapore)",
    "Abstract of your proposal": "This talk will begin with a gentle introduction to trace theory, a principled mathematical framework for defining equivalence relations among concurrent program executions based on a commutativity relation over the atomic steps of individual program threads. Its simplicity, elegance, and algorithmic efficiency make it a powerful tool in various domains, including program verification and testing.\nI will then compare trace theory with the modern, widely adopted notion of equivalence for concurrent program executions, known as reads-from equivalence. This more natural and relaxed notion captures a broader range of behaviors but introduces significant computational challenges. Specifically, I will present results demonstrating the computational hardness associated with reads-from equivalence.\nFinally, I will discuss our recent efforts to generalize trace theory to reconcile it with reads-from equivalence. This generalized framework aims to retain the algorithmic advantages of trace theory while addressing its limitations in representing modern equivalence notions.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "1. Coarser Equivalences for Causal Concurrency, Azadeh Farzan and Umang Mathur, POPL 2024\n2. Predictive Monitoring against Pattern Regular Languages, Zhendong Ang and Umang Mathur, POPL 2024\n3. Predictive Monitoring with Strong Trace Prefixes, Zhendong Ang and Umang Mathur, CAV 2024",
    "Mobile Number": "+6593512956 (Whatsapp)",
    "Rank": "A"
  },
  {
    "Timestamp": "10-23-2025 18:54:03",
    "Email Address": "afzal.2@tcs.com",
    "Select an appropriate category for your proposal": "Talk",
    "Title of your proposal": "Confidence-aware local robustness verification of neural networks",
    "Name of the presenter": "Mohammad Afzal",
    "Affiliation": "TCS Pune India and IIT Bombay",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Ashutosh Gupta, IIT Bombay\nS Akshay, IIT Bombay",
    "Abstract of your proposal": "Robustness is a important problem in AI alignment and safety, with models such as neural networks being increasingly used in safety-critical systems. In the last decade, a large body of work has emerged on local robustness, i.e., checking if the decision of a neural network remains unchanged when the input is slightly perturbed. However, many of these approaches require specialized encodings and often ignore the confidence of a neural network on its output.\n\nIn this work, our goal is to build a generalised framework to specify and verify variants of robustness in neural network verification. We propose a specification framework using a simple grammar, which is flexible enough to capture most existing variants. This allows us to introduce new variants of robustness that take into account the confidence of the neural network in its outputs. Next, we develop a novel and powerful unified technique to verify all such variants in a homogenous way, viz., by adding a few additional layers to the neural network. This enables us to use any state-of-the-art neural network verification tool, without having to tinker with the encoding within, while incurring an approximation error that we show is bounded.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Not Available",
    "Mobile Number": 9793132904,
    "Rank": "U"
  },
  {
    "Timestamp": "9-17-2025 17:42:39",
    "Email Address": "praneethjain005@gmail.com",
    "Select an appropriate category for your proposal": "Poster",
    "Title of your proposal": "SimpliPy: A Source-Tracking Notional Machine for Simplified Python",
    "Name of the presenter": "Moida Praneeth Jain",
    "Affiliation": "International Institute of Information Technology - Hyderabad",
    "Current role/position": "Bachelors student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Venkatesh Choppella, International Institute of Information Technology - Hyderabad",
    "Abstract of your proposal": "Misconceptions about program execution hinder many novice\nprogrammers. We introduce SimpliPy, a notional machine designed around\na carefully chosen Python subset to clarify core control flow and scoping\nconcepts. Its foundation is a precise operational semantics that explicitly\ntracks source code line numbers for each execution step, making the link\nbetween code and behavior unambiguous. Complementing the dynamic\nsemantics, SimpliPy uses static analysis to generate Control Flow Graphs\n(CFGs) and identify lexical scopes, helping students build a structural\nunderstanding before tracing. We also present an interactive web-based\ndebugger built on these principles. This tool embodies the formal tech-\nniques, visualizing the operational state (environments, stack) and using\nthe static CFG to animate control flow directly on the graph during\nstep-by-step execution. SimpliPy thus integrates formal semantics, pro-\ngram analysis, and visualization to offer both a pedagogical approach\nand a practical demonstration of applying formal methods to program\nunderstanding.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "https://drive.google.com/file/d/1SSBj0Cdn6CaKlGUEit6IE2G8_lCtnEtJ/view?usp=sharing",
    "Mobile Number": 6264381767,
    "Rank": ""
  },
  {
    "Timestamp": "9-25-2025 11:19:24",
    "Email Address": "atanu94kundu@gmail.com",
    "Select an appropriate category for your proposal": "Poster",
    "Title of your proposal": "A CEGAR-centric Bounded Reachability Analysis for Compositional Affine Hybrid Systems",
    "Name of the presenter": "Atanu Kundu",
    "Affiliation": "Indian Association for the Cultivation of Science",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Atanu Kundu  Indian Association for the Cultivation of Science, Kolkata\nPratyay Sarkar  Indian Association for the Cultivation of Science, Kolkata\nRajarshi Ray  Indian Association for the Cultivation of Science, Kolkata",
    "Abstract of your proposal": "Reachability analysis of compositional hybrid systems, where individual components are modeled as hybrid automata, poses unique challenges. In addition to preserving the compositional semantics while computing system behaviors, algorithms have to cater to the explosion in the number of locations in the parallel product automaton. In this paper, we propose a bounded reachability analysis algorithm for compositional hybrid systems with piecewise affine dynamics, based on the principle of counterexample guided abstraction refinement (CEGAR). In particular, the algorithm searches for a counterexample in the discrete abstraction of the composition model, without explicitly computing a product automaton. When a counterexample is discovered in the abstraction, its validity is verified by a refinement of the state-space guided by the abstract counterexample. The state-space refinement is through a symbolic reachability analysis, particularly using a state-of-the-art algorithm with support functions as the continuous state representation. In addition, the algorithm mixes different semantics of composition with the objective of improved efficiency. Step compositional semantics is followed while exploring the abstract (discrete) state-space, while shallow compositional semantics is followed during state-space refinement with symbolic reachability analysis. Optimizations such as caching the results of the symbolic reachability analysis, which can be later reused, have been proposed. We implement this algorithm in the tool SAT-Reach and demonstrate the scalability benefits.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "https://arxiv.org/abs/2509.03560",
    "Mobile Number": 8617035504,
    "Rank": ""
  },
  {
    "Timestamp": "10-3-2025 16:43:04",
    "Email Address": "mutilin@ispras.ru",
    "Select an appropriate category for your proposal": "Poster",
    "Title of your proposal": "RaceHunter-Fuzzer: Coverage-Guided Fuzzing of Inputs and Schedules for Detecting Concurrency Bugs",
    "Name of the presenter": "Vadim Mutilin",
    "Affiliation": "Ivannikov Institute for System Programming of the RAS",
    "Current role/position": "Faculty",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Pavel Andrianov, Evgeniy Gerlits, Vitaly Mordan, Veronika Rudenchik",
    "Abstract of your proposal": "Concurrency bugs remain among the most challenging issues in software development because they often manifest rarely and unpredictably. Their appearance depends not only on program inputs but also on the specific interleavings of concurrent schedules.\nAs a result, detecting such bugs requires exploring two vast spaces: inputs and schedules.\n\nWe propose a preliminary approach to address both dimensions. Our method builds on the RaceHunter tool, which systematically explores concurrent schedules. We extend it with a new component, RaceHunter-Fuzzer, which integrates a fuzzing loop that mutates both schedules and inputs, guided by coverage feedback. Unlike approaches that generate synthetic schedules, our schedule mutation strategy is stateful: it reuses information from previously observed executions.\n\nTo further direct fuzzing toward promising inputs, we introduce concurrency conflicting-pair coverage, which helps selecting inputs that may trigger concurrency issues.\n\nThere are several related efforts in concurrency fuzzing, such as MUZZ and CONZZER. Compared to MUZZ, our approach systematically explores schedules rather than relying on randomness. While CONZZER mutates adjacency-directed call pairs to produce new thread interleavings, RaceHunter-Fuzzer instead mutates individual access pairs.\n\nWe evaluated the RaceHunter-Fuzzer approach by comparing it to the baseline RaceHunter on QEMU concurrency unit tests. In the first experiment, we iterated over a relatively small set of concrete input combinations. Preliminary results indicate that RaceHunter-Fuzzer outperforms the baseline by systematically exploring the full range of input combinations and using coverage feedback to eliminate redundant executions. In contrast, RaceHunter is limited to exploring a single input combination per run.\n\nAdditionally, we demonstrated that even when operating over unbounded input spaces, RaceHunter-Fuzzer successfully detects the same concurrency bugs as the original tool.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Not Available",
    "Mobile Number": "+79035104623",
    "Rank": ""
  },
  {
    "Timestamp": "10-3-2025 22:35:32",
    "Email Address": "yashika@cse.iitb.ac.in",
    "Select an appropriate category for your proposal": "Poster",
    "Title of your proposal": "Analyzing Correlation between Design Properties and Refactorings",
    "Name of the presenter": "Yashika Kashyap",
    "Affiliation": "IIT Bombay",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Rushikesh K. Joshi, CSE, IIT Bombay",
    "Abstract of your proposal": "Software systems, as they evolve, accumulate technical debt that often leads to inefficient code structures, higher computational overhead, and excessive energy consumption. These inefficiencies not only degrade maintainability and performance but also contribute to the rising environmental footprint of software execution, particularly in energy-intensive domains such as cloud computing and large-scale data processing. Code smells are defects in code, which can be used to detect needs for refactorings. Design metrics may be used to detect code smells. Code refactoring, the practice of restructuring code without altering external behavior, has traditionally been studied for its benefits in maintainability, defect reduction, and productivity. \nThis proposal explores the intersection of code refactorings, design bad smells and design properties by analyzing a few datasets.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Not Available",
    "Mobile Number": 9891008308,
    "Rank": ""
  },
  {
    "Timestamp": "10-4-2025 11:19:42",
    "Email Address": "jayab@cse.iitb.ac.in",
    "Select an appropriate category for your proposal": "Poster",
    "Title of your proposal": "Testing multiple LLMs for Design Pattern Code Generations",
    "Name of the presenter": "Jaya Bharti",
    "Affiliation": "IIT Bombay",
    "Current role/position": "PhD student",
    "Your collaborators on the proposal. Mention their names and affiliation, one name + affiliation per line": "Rushikesh K. Joshi, CSE, IIT Bombay",
    "Abstract of your proposal": "This work investigates whether Large Language Models (LLMs) can implicitly recognize and implement software design patterns from natural language problem statements. We focus on two behavioral design patterns?Template Method and Chain of Responsibility?and evaluate multiple LLMs using prompts that do not explicitly mention the patterns. The study analyzes whether the models can infer the appropriate pattern and generate correct, compilable code. While prior work has primarily explored Java and Python, the use of C++ for such evaluations remains underexplored. This study emphasizes C++ code generation, with results compared across LLMs in terms of accuracy, structural correctness, and code efficiency.",
    "Publications/pre-prints/technical reports your proposal is based on.\n\n- For the published aspects of your proposal, please provide the publication details including the publication title, authors, conference/journal name and publication year. If there are": "Not Available",
    "Mobile Number": 7999887127,
    "Rank": ""
  }
]
export default proposals;